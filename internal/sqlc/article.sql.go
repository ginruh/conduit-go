// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: article.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createArticle = `-- name: CreateArticle :one
INSERT INTO "article" (slug, title, description, body, author_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, slug, title, description, body, created_at, updated_at, author_id
`

type CreateArticleParams struct {
	Slug        string
	Title       string
	Description string
	Body        string
	AuthorID    int32
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.Slug,
		arg.Title,
		arg.Description,
		arg.Body,
		arg.AuthorID,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorID,
	)
	return i, err
}

const deleteArticle = `-- name: DeleteArticle :one
DELETE FROM "article"
WHERE slug = $1
RETURNING id, slug, title, description, body, created_at, updated_at, author_id
`

func (q *Queries) DeleteArticle(ctx context.Context, slug string) (Article, error) {
	row := q.db.QueryRowContext(ctx, deleteArticle, slug)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorID,
	)
	return i, err
}

const getArticle = `-- name: GetArticle :one
SELECT
    a.slug,
    a.title,
    a.description,
    a.body,
    u.username,
    u.bio,
    u.image,
    CASE WHEN uf.following IS null THEN FALSE ELSE TRUE END AS user_following,
    CASE WHEN af.favorites IS null THEN 0 ELSE CAST(af.favorites AS INTEGER) END AS favorites_count,
    CASE WHEN af_favorited.favorited IS null THEN FALSE ELSE TRUE END as favorited,
    CASE WHEN at.tags IS NULL THEN '' ELSE CAST(at.tags AS VARCHAR) END AS tags,
    a.created_at,
    a.updated_at
FROM article AS a
    LEFT JOIN "user" AS u ON a.author_id = u.id
    LEFT JOIN
        (SELECT uf.user_id, uf.follower_id, count(*) as following FROM user_follower as uf GROUP BY uf.user_id, uf.follower_id) as uf
    ON uf.follower_id = a.author_id AND uf.user_id = $2
    LEFT JOIN
        (SELECT article_id, COUNT(*) as favorites FROM article_favorite as af GROUP BY af.article_id) as af
    ON a.id = af.article_id
    LEFT JOIN
        (SELECT af.article_id, af.user_id, COUNT(*) as favorited FROM article_favorite as af GROUP BY af.article_id, af.user_id) as af_favorited
    ON a.id = af_favorited.article_id AND af_favorited.user_id = $2
    LEFT JOIN
        (SELECT at.article_id, STRING_AGG(at.tag_name, ',') AS tags FROM article_tags AS at GROUP BY at.article_id) as at
    ON a.id = at.article_id AND at.article_id = a.id
WHERE a.slug = $1
`

type GetArticleParams struct {
	Slug   string
	UserID int32
}

type GetArticleRow struct {
	Slug           string
	Title          string
	Description    string
	Body           string
	Username       sql.NullString
	Bio            sql.NullString
	Image          sql.NullString
	UserFollowing  bool
	FavoritesCount int32
	Favorited      bool
	Tags           string
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
}

func (q *Queries) GetArticle(ctx context.Context, arg GetArticleParams) (GetArticleRow, error) {
	row := q.db.QueryRowContext(ctx, getArticle, arg.Slug, arg.UserID)
	var i GetArticleRow
	err := row.Scan(
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Body,
		&i.Username,
		&i.Bio,
		&i.Image,
		&i.UserFollowing,
		&i.FavoritesCount,
		&i.Favorited,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateArticle = `-- name: UpdateArticle :one
UPDATE "article"
SET slug = $2, title = $3, description = $4, body = $5
WHERE id = $1
RETURNING id, slug, title, description, body, created_at, updated_at, author_id
`

type UpdateArticleParams struct {
	ID          int32
	Slug        string
	Title       string
	Description string
	Body        string
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, updateArticle,
		arg.ID,
		arg.Slug,
		arg.Title,
		arg.Description,
		arg.Body,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorID,
	)
	return i, err
}
